{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/lucas/Desktop/advanced/frontend/new_components/molecules/animations/Slide.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Libs\nimport React, { useEffect, useRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { debounce } from \"lodash\"; // Components\n\nimport { Transition } from \"react-transition-group\";\nimport { useForkRef } from \"../../_utils\";\nimport { DURATION, EASING, createAnimation } from \"./_utils\";\nexport const SLIDE_DIRECTION = {\n  LEFT: \"left\",\n  RIGHT: \"right\",\n  UP: \"up\",\n  DOWN: \"down\"\n};\n/**\n * Translate the node so it can't be seen on the screen\n * @param {string} direction Either \"left\", \"right\", \"up\" or \"down\"\n * @param {object} node Node to translate\n */\n\nfunction getTranslateValue(direction, node) {\n  var _computedStyle$getPro;\n\n  const rect = node.getBoundingClientRect();\n  const computedStyle = window.getComputedStyle(node);\n  const transform = (_computedStyle$getPro = computedStyle.getPropertyValue(\"-webkit-transform\")) !== null && _computedStyle$getPro !== void 0 ? _computedStyle$getPro : computedStyle.getPropertyValue(\"transform\");\n  let offsetX = 0;\n  let offsetY = 0;\n\n  if (transform && transform !== \"none\" && typeof transform === \"string\") {\n    const transformValues = transform.split(\"(\")[1].split(\")\")[0].split(\",\");\n    offsetX = parseInt(transformValues[4], 10);\n    offsetY = parseInt(transformValues[5], 10);\n  }\n\n  if (direction === SLIDE_DIRECTION.LEFT) {\n    return `translateX(${window.innerWidth}px) translateX(${offsetX - rect.left}px)`;\n  }\n\n  if (direction === SLIDE_DIRECTION.RIGHT) {\n    return `translateX(-${rect.left + rect.width - offsetX}px)`;\n  }\n\n  if (direction === SLIDE_DIRECTION.UP) {\n    return `translateY(${window.innerHeight}px) translateY(${offsetY - rect.top}px)`;\n  } // direction === SLIDE_DIRECTION.DOWN\n\n\n  return `translateY(-${rect.top + rect.height - offsetY}px)`;\n}\n\nfunction setTranslateValue(direction, node) {\n  if (!node) {\n    return;\n  }\n\n  const transform = getTranslateValue(direction, node);\n\n  if (transform) {\n    node.style.webkitTransform = transform;\n    node.style.transform = transform;\n  }\n}\n\nconst defaultTimeout = {\n  enter: DURATION.enteringScreen,\n  exit: DURATION.leavingScreen\n};\nexport function Slide({\n  appear = true,\n  children,\n  direction = SLIDE_DIRECTION.LEFT,\n  in: inProp,\n  onEnter,\n  onEntered,\n  onEntering,\n  onExit,\n  onExited,\n  onExiting,\n  timeout = defaultTimeout,\n  transitionProps\n}) {\n  const ref = useRef(null);\n  const handleRef = useForkRef(ref, children.ref);\n\n  const normalizedTransitionCallback = callback => isAppearing => {\n    if (!callback) {\n      return;\n    }\n\n    if (isAppearing === undefined) {\n      callback(ref.current);\n    } else {\n      callback(ref.current, isAppearing);\n    }\n  };\n\n  const handleEnter = normalizedTransitionCallback((node, isAppearing) => {\n    setTranslateValue(direction, node);\n\n    if (onEnter) {\n      onEnter(node, isAppearing);\n    }\n  });\n  const handleEntering = normalizedTransitionCallback((node, isAppearing) => {\n    const animationProps = {\n      duration: timeout.enter,\n      easing: EASING.easeOut\n    };\n    node.style.webkitTransition = createAnimation(\"-webkit-transform\", animationProps);\n    node.style.transition = createAnimation(\"transform\", animationProps);\n    node.style.webkitTransform = \"none\";\n    node.style.transform = \"none\";\n\n    if (onEntering) {\n      onEntering(node, isAppearing);\n    }\n  });\n  const handleEntered = normalizedTransitionCallback(onEntered);\n  const handleExit = normalizedTransitionCallback(node => {\n    const animationProps = {\n      duration: timeout.exit,\n      easing: EASING.sharp\n    };\n    node.style.webkitTransition = createAnimation(\"-webkit-transform\", animationProps);\n    node.style.transition = createAnimation(\"transform\", animationProps);\n    setTranslateValue(direction, node);\n\n    if (onExit) {\n      onExit(node);\n    }\n  });\n  const handleExiting = normalizedTransitionCallback(onExiting);\n  const handleExited = normalizedTransitionCallback(node => {\n    // No need for transitions when the component is hidden\n    node.style.webkitTransition = \"\";\n    node.style.transition = \"\";\n\n    if (onExited) {\n      onExited(node);\n    }\n  });\n  useEffect(() => {\n    // We skip configuration if the position makes it screen size invariant\n    if (inProp || [SLIDE_DIRECTION.DOWN, SLIDE_DIRECTION.RIGHT].includes(direction)) {\n      return;\n    }\n\n    const handleResize = debounce(() => {\n      if (ref.current) {\n        setTranslateValue(direction, ref.current);\n      }\n    });\n    window.addEventListener(\"resize\", handleResize);\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, [inProp, direction]);\n  useEffect(() => {\n    // We need to update the position of the drawer when the direction changes and when it's hidden\n    if (!inProp && ref.current) {\n      setTranslateValue(direction, ref.current);\n    }\n  }, [inProp, direction]);\n  return /*#__PURE__*/_jsxDEV(Transition, _objectSpread(_objectSpread({}, transitionProps), {}, {\n    nodeRef: ref,\n    onEnter: handleEnter,\n    onEntered: handleEntered,\n    onEntering: handleEntering,\n    onExit: handleExit,\n    onExited: handleExited,\n    onExiting: handleExiting,\n    appear: appear,\n    in: inProp,\n    timeout: timeout,\n    children: (state, childProps) => /*#__PURE__*/React.cloneElement(children, _objectSpread({\n      ref: handleRef,\n      style: _objectSpread(_objectSpread({}, children.props.style), {}, {\n        visibility: state === \"exited\" && !inProp ? \"hidden\" : undefined\n      })\n    }, childProps))\n  }), void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 184,\n    columnNumber: 9\n  }, this);\n}\nSlide.propTypes = {\n  /**\n   * If element should appear with animation\n   */\n  appear: PropTypes.bool,\n\n  /**\n   * Children to display\n   */\n  children: PropTypes.node,\n\n  /**\n   * Direction to appear with\n   */\n  direction: PropTypes.oneOf(Object.values(SLIDE_DIRECTION)),\n\n  /**\n   * If component is showed\n   */\n  in: PropTypes.bool,\n\n  /**\n   * Enter handler\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Entered handler\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Entering handler\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Exit handler\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Exited handler\n   */\n  onExited: PropTypes.func,\n\n  /**\n   * Exiting handler\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * Timeout for transitions\n   */\n  timeout: PropTypes.shape({\n    enter: PropTypes.number,\n    exit: PropTypes.number\n  }),\n\n  /**\n   * Additional props for Transition\n   */\n  transitionProps: PropTypes.shape(Transition.propTypes)\n};","map":{"version":3,"sources":["/Users/lucas/Desktop/advanced/frontend/new_components/molecules/animations/Slide.js"],"names":["React","useEffect","useRef","PropTypes","debounce","Transition","useForkRef","DURATION","EASING","createAnimation","SLIDE_DIRECTION","LEFT","RIGHT","UP","DOWN","getTranslateValue","direction","node","rect","getBoundingClientRect","computedStyle","window","getComputedStyle","transform","getPropertyValue","offsetX","offsetY","transformValues","split","parseInt","innerWidth","left","width","innerHeight","top","height","setTranslateValue","style","webkitTransform","defaultTimeout","enter","enteringScreen","exit","leavingScreen","Slide","appear","children","in","inProp","onEnter","onEntered","onEntering","onExit","onExited","onExiting","timeout","transitionProps","ref","handleRef","normalizedTransitionCallback","callback","isAppearing","undefined","current","handleEnter","handleEntering","animationProps","duration","easing","easeOut","webkitTransition","transition","handleEntered","handleExit","sharp","handleExiting","handleExited","includes","handleResize","addEventListener","removeEventListener","state","childProps","cloneElement","props","visibility","propTypes","bool","oneOf","Object","values","func","shape","number"],"mappings":"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","sourcesContent":["// Libs\nimport React, { useEffect, useRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { debounce } from \"lodash\";\n\n// Components\nimport { Transition } from \"react-transition-group\";\n\nimport { useForkRef } from \"../../_utils\";\nimport { DURATION, EASING, createAnimation } from \"./_utils\";\n\nexport const SLIDE_DIRECTION = {\n    LEFT: \"left\",\n    RIGHT: \"right\",\n    UP: \"up\",\n    DOWN: \"down\",\n};\n\n/**\n * Translate the node so it can't be seen on the screen\n * @param {string} direction Either \"left\", \"right\", \"up\" or \"down\"\n * @param {object} node Node to translate\n */\nfunction getTranslateValue(direction, node) {\n    const rect = node.getBoundingClientRect();\n\n    const computedStyle = window.getComputedStyle(node);\n    const transform =\n        computedStyle.getPropertyValue(\"-webkit-transform\") ?? computedStyle.getPropertyValue(\"transform\");\n\n    let offsetX = 0;\n    let offsetY = 0;\n\n    if (transform && transform !== \"none\" && typeof transform === \"string\") {\n        const transformValues = transform.split(\"(\")[1].split(\")\")[0].split(\",\");\n        offsetX = parseInt(transformValues[4], 10);\n        offsetY = parseInt(transformValues[5], 10);\n    }\n\n    if (direction === SLIDE_DIRECTION.LEFT) {\n        return `translateX(${window.innerWidth}px) translateX(${offsetX - rect.left}px)`;\n    }\n\n    if (direction === SLIDE_DIRECTION.RIGHT) {\n        return `translateX(-${rect.left + rect.width - offsetX}px)`;\n    }\n\n    if (direction === SLIDE_DIRECTION.UP) {\n        return `translateY(${window.innerHeight}px) translateY(${offsetY - rect.top}px)`;\n    }\n\n    // direction === SLIDE_DIRECTION.DOWN\n    return `translateY(-${rect.top + rect.height - offsetY}px)`;\n}\n\nfunction setTranslateValue(direction, node) {\n    if (!node) {\n        return;\n    }\n\n    const transform = getTranslateValue(direction, node);\n\n    if (transform) {\n        node.style.webkitTransform = transform;\n        node.style.transform = transform;\n    }\n}\n\nconst defaultTimeout = {\n    enter: DURATION.enteringScreen,\n    exit: DURATION.leavingScreen,\n};\n\nexport function Slide({\n    appear = true,\n    children,\n    direction = SLIDE_DIRECTION.LEFT,\n    in: inProp,\n    onEnter,\n    onEntered,\n    onEntering,\n    onExit,\n    onExited,\n    onExiting,\n    timeout = defaultTimeout,\n    transitionProps,\n}) {\n    const ref = useRef(null);\n    const handleRef = useForkRef(ref, children.ref);\n\n    const normalizedTransitionCallback = (callback) => (isAppearing) => {\n        if (!callback) {\n            return;\n        }\n\n        if (isAppearing === undefined) {\n            callback(ref.current);\n        } else {\n            callback(ref.current, isAppearing);\n        }\n    };\n\n    const handleEnter = normalizedTransitionCallback((node, isAppearing) => {\n        setTranslateValue(direction, node);\n\n        if (onEnter) {\n            onEnter(node, isAppearing);\n        }\n    });\n\n    const handleEntering = normalizedTransitionCallback((node, isAppearing) => {\n        const animationProps = {\n            duration: timeout.enter,\n            easing: EASING.easeOut,\n        };\n\n        node.style.webkitTransition = createAnimation(\"-webkit-transform\", animationProps);\n        node.style.transition = createAnimation(\"transform\", animationProps);\n        node.style.webkitTransform = \"none\";\n        node.style.transform = \"none\";\n\n        if (onEntering) {\n            onEntering(node, isAppearing);\n        }\n    });\n\n    const handleEntered = normalizedTransitionCallback(onEntered);\n\n    const handleExit = normalizedTransitionCallback((node) => {\n        const animationProps = {\n            duration: timeout.exit,\n            easing: EASING.sharp,\n        };\n\n        node.style.webkitTransition = createAnimation(\"-webkit-transform\", animationProps);\n        node.style.transition = createAnimation(\"transform\", animationProps);\n\n        setTranslateValue(direction, node);\n\n        if (onExit) {\n            onExit(node);\n        }\n    });\n\n    const handleExiting = normalizedTransitionCallback(onExiting);\n\n    const handleExited = normalizedTransitionCallback((node) => {\n        // No need for transitions when the component is hidden\n        node.style.webkitTransition = \"\";\n        node.style.transition = \"\";\n\n        if (onExited) {\n            onExited(node);\n        }\n    });\n\n    useEffect(() => {\n        // We skip configuration if the position makes it screen size invariant\n        if (inProp || [SLIDE_DIRECTION.DOWN, SLIDE_DIRECTION.RIGHT].includes(direction)) {\n            return;\n        }\n\n        const handleResize = debounce(() => {\n            if (ref.current) {\n                setTranslateValue(direction, ref.current);\n            }\n        });\n\n        window.addEventListener(\"resize\", handleResize);\n\n        return () => {\n            window.removeEventListener(\"resize\", handleResize);\n        };\n    }, [inProp, direction]);\n\n    useEffect(() => {\n        // We need to update the position of the drawer when the direction changes and when it's hidden\n        if (!inProp && ref.current) {\n            setTranslateValue(direction, ref.current);\n        }\n    }, [inProp, direction]);\n\n    return (\n        <Transition\n            {...transitionProps}\n            nodeRef={ref}\n            onEnter={handleEnter}\n            onEntered={handleEntered}\n            onEntering={handleEntering}\n            onExit={handleExit}\n            onExited={handleExited}\n            onExiting={handleExiting}\n            appear={appear}\n            in={inProp}\n            timeout={timeout}\n        >\n            {(state, childProps) =>\n                React.cloneElement(children, {\n                    ref: handleRef,\n                    style: {\n                        ...children.props.style,\n                        visibility: state === \"exited\" && !inProp ? \"hidden\" : undefined,\n                    },\n                    ...childProps,\n                })\n            }\n        </Transition>\n    );\n}\n\nSlide.propTypes = {\n    /**\n     * If element should appear with animation\n     */\n    appear: PropTypes.bool,\n    /**\n     * Children to display\n     */\n    children: PropTypes.node,\n    /**\n     * Direction to appear with\n     */\n    direction: PropTypes.oneOf(Object.values(SLIDE_DIRECTION)),\n    /**\n     * If component is showed\n     */\n    in: PropTypes.bool,\n    /**\n     * Enter handler\n     */\n    onEnter: PropTypes.func,\n    /**\n     * Entered handler\n     */\n    onEntered: PropTypes.func,\n    /**\n     * Entering handler\n     */\n    onEntering: PropTypes.func,\n    /**\n     * Exit handler\n     */\n    onExit: PropTypes.func,\n    /**\n     * Exited handler\n     */\n    onExited: PropTypes.func,\n    /**\n     * Exiting handler\n     */\n    onExiting: PropTypes.func,\n    /**\n     * Timeout for transitions\n     */\n    timeout: PropTypes.shape({\n        enter: PropTypes.number,\n        exit: PropTypes.number,\n    }),\n    /**\n     * Additional props for Transition\n     */\n    transitionProps: PropTypes.shape(Transition.propTypes),\n};\n"]},"metadata":{},"sourceType":"module"}