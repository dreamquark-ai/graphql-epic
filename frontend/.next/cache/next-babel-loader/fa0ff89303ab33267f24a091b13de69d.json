{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/lucas/Desktop/advanced/frontend/new_components/_utils/elements.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n// Libs\nimport React from \"react\";\nimport classnames from \"classnames\";\nimport { isEmpty } from \"lodash\";\nimport { compact } from \"lodash/fp\";\n/**\n * Wrap child in a span if it is a string\n * @param {React.Element} child Child element\n */\n\nexport function wrapLabel(child) {\n  if (isEmpty(child)) {\n    throw new Error(\"you should have a child\");\n  }\n\n  return typeof child === \"string\" ? /*#__PURE__*/_jsxDEV(\"span\", {\n    children: child\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 16,\n    columnNumber: 40\n  }, this) : child;\n}\n/**\n * Merge props into components with special care for className\n * @param {React.node} element Child element(s)\n * @param {object} props Props to merge\n */\n\nexport function mergeProps(element, _ref) {\n  let {\n    className: classNameB\n  } = _ref,\n      otherPropsB = _objectWithoutProperties(_ref, [\"className\"]);\n\n  if (!element) {\n    return element;\n  }\n\n  const _element$props = element.props,\n        {\n    className: classNameA\n  } = _element$props,\n        otherPropsA = _objectWithoutProperties(_element$props, [\"className\"]);\n\n  return /*#__PURE__*/React.cloneElement(element, _objectSpread(_objectSpread(_objectSpread({}, otherPropsA), otherPropsB), {}, {\n    className: classnames(classNameA, classNameB)\n  }));\n}\n/**\n * Merge props into components with care for nullish components and complex structure\n * @param {React.node} children Child element(s)\n * @param {object} props Props to merge\n */\n\nexport function alterElement(children, props) {\n  if (!children) {\n    return;\n  }\n\n  return Array.isArray(children) ? React.Children.map(compact(children), child => mergeProps(wrapLabel(child), props)) : mergeProps(wrapLabel(children), props);\n}","map":{"version":3,"sources":["/Users/lucas/Desktop/advanced/frontend/new_components/_utils/elements.js"],"names":["React","classnames","isEmpty","compact","wrapLabel","child","Error","mergeProps","element","className","classNameB","otherPropsB","props","classNameA","otherPropsA","cloneElement","alterElement","children","Array","isArray","Children","map"],"mappings":";;;;;;;;;;;;;AAAA;AACA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,UAAP,MAAuB,YAAvB;AACA,SAASC,OAAT,QAAwB,QAAxB;AACA,SAASC,OAAT,QAAwB,WAAxB;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AAC7B,MAAIH,OAAO,CAACG,KAAD,CAAX,EAAoB;AAChB,UAAM,IAAIC,KAAJ,CAAU,yBAAV,CAAN;AACH;;AAED,SAAO,OAAOD,KAAP,KAAiB,QAAjB,gBAA4B;AAAA,cAAOA;AAAP;AAAA;AAAA;AAAA;AAAA,UAA5B,GAAmDA,KAA1D;AACH;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,UAAT,CAAoBC,OAApB,QAAwE;AAAA,MAA3C;AAAEC,IAAAA,SAAS,EAAEC;AAAb,GAA2C;AAAA,MAAfC,WAAe;;AAC3E,MAAI,CAACH,OAAL,EAAc;AACV,WAAOA,OAAP;AACH;;AAED,yBAAkDA,OAAO,CAACI,KAA1D;AAAA,QAAM;AAAEH,IAAAA,SAAS,EAAEI;AAAb,GAAN;AAAA,QAAkCC,WAAlC;;AAEA,sBAAOd,KAAK,CAACe,YAAN,CAAmBP,OAAnB,gDACAM,WADA,GAEAH,WAFA;AAGHF,IAAAA,SAAS,EAAER,UAAU,CAACY,UAAD,EAAaH,UAAb;AAHlB,KAAP;AAKH;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,YAAT,CAAsBC,QAAtB,EAAgCL,KAAhC,EAAuC;AAC1C,MAAI,CAACK,QAAL,EAAe;AACX;AACH;;AAED,SAAOC,KAAK,CAACC,OAAN,CAAcF,QAAd,IACDjB,KAAK,CAACoB,QAAN,CAAeC,GAAf,CAAmBlB,OAAO,CAACc,QAAD,CAA1B,EAAuCZ,KAAD,IAAWE,UAAU,CAACH,SAAS,CAACC,KAAD,CAAV,EAAmBO,KAAnB,CAA3D,CADC,GAEDL,UAAU,CAACH,SAAS,CAACa,QAAD,CAAV,EAAsBL,KAAtB,CAFhB;AAGH","sourcesContent":["// Libs\nimport React from \"react\";\nimport classnames from \"classnames\";\nimport { isEmpty } from \"lodash\";\nimport { compact } from \"lodash/fp\";\n\n/**\n * Wrap child in a span if it is a string\n * @param {React.Element} child Child element\n */\nexport function wrapLabel(child) {\n    if (isEmpty(child)) {\n        throw new Error(\"you should have a child\");\n    }\n\n    return typeof child === \"string\" ? <span>{child}</span> : child;\n}\n\n/**\n * Merge props into components with special care for className\n * @param {React.node} element Child element(s)\n * @param {object} props Props to merge\n */\nexport function mergeProps(element, { className: classNameB, ...otherPropsB }) {\n    if (!element) {\n        return element;\n    }\n\n    const { className: classNameA, ...otherPropsA } = element.props;\n\n    return React.cloneElement(element, {\n        ...otherPropsA,\n        ...otherPropsB,\n        className: classnames(classNameA, classNameB),\n    });\n}\n\n/**\n * Merge props into components with care for nullish components and complex structure\n * @param {React.node} children Child element(s)\n * @param {object} props Props to merge\n */\nexport function alterElement(children, props) {\n    if (!children) {\n        return;\n    }\n\n    return Array.isArray(children)\n        ? React.Children.map(compact(children), (child) => mergeProps(wrapLabel(child), props))\n        : mergeProps(wrapLabel(children), props);\n}\n"]},"metadata":{},"sourceType":"module"}